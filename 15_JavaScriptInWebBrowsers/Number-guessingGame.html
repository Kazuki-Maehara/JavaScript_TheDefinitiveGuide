<html>

<head>
  <title>I'm thinking of a number...</title>
  <style>
    body {
      height: 250px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: space-evenly;
    }

    #heading {
      font: bold 36px sans-serif;
      margin: 0;
    }

    #container {
      border: solid black 1px;
      height: 1em;
      witdh: 80%;
    }

    #range {
      background-color: green;
      margin-left: 0%;
      height: 1em;
      height: 1em;
      width: 100%;
    }

    #input {
      display: block;
      font-size: 24px;
      width: 60%;
      padding: 5px;
    }

    #playagain {
      font-size: 24px;
      padding: 10px;
      border-radius: 5px;
    }
  </style>
</head>

<body>
  <h1 id="heading">I'm thinking of a number...</h1>
  <!-- A visual representation of the numbers that have not been ruled out -->
  <div id="container"><div id="range"></div></div>
  <!-- Where the user enters their guess -->
  <input id="input" type="text">
  <!-- A button that reloads with no search string. Hidden until game ends. -->
  <button id="playagain" hidden onclick="location.search='';">Play Again</button>
  <script>
    /**
    * An instance of this GameState class represents the internal state of
    * our number guessing game. The class defines static factory methods for
    * updating the state based on a new guess, and a method for modifying the
    * document based on the current state.
    **/
    class GameState {
      // This is a factory function to create a new game
      static newGame() {
        let s = new GameState();
        s.secret = s.randomInt(0, 100);     // An integer: 0 < n < 100;
        s.low = 0;                          // Guesses must be greater than this
        s.high = 100;                       // Guesses must be less than this
        s.numberGuesses = 0;                // How many guesses have been made
        s.guess = null;                     // What the last guess was
        return s;
      }

      // When we save the state of the game with history.pushState(), it is just
      // a plain JavaScript object that gets saved, not an instance of GameState.
      // So this factory function re-creates a GameState object based on the
      // plain object that we get from a popstate event.
      static fromStateObject(stateObject) {
        let s = new GameState();
        for (let key of Object.keys(stateObject)) {
          s[key] = stateObject[key];
        }
        return s;
      }

      // In order to enable bookmarking, we need to be able to encode the
      // state of any game as a URL. This is easy to do with URLSearchParams.
      toURL() {
        let url = new URL(window.location);
        url.searchParams.set("l", this.low);
        url.searchParams.set("h", this.high);
        url.searchParams.set("n", this.numGuess);
        url.searchParams.set("g", this.guess);
        // Note that we can't encode the secret number in the url or it
        // will give away the secret. If the user book marks the page with
        // these parameters and then returns to it, we will simply pick a
        // new random number between low and high.
        return url.href;
      }

      // This is a factory function that creates a new GameState object and
      // initializes it from the specified URL. If the URL does not contain the
      // expected parameters or if they are malformed it just returns null.
    }
  </script>
</body>

</html>
